#version 460 core

#line 3


// Static settings
// ---------------

// BRANCHING_FACTOR macro could defined from the outside
#ifndef BRANCHING_FACTOR
    // tile size for branching factor: n = 4
    #define BRANCHING_FACTOR  4  // n <- keep this powers of two
#endif

#ifndef BRICK_SIDE_LENGTH
    #define BRICK_SIDE_LENGTH 8  // lets have NxNxN bricks
#endif
#if BRICK_SIDE_LENGTH == 8
    // Computation of 3D discrete location of brick in brick atlas texture:
    //   return uvec3(
    //       brickIndex % 8,
    //       (brickIndex / 8) % 8,
    //       brickIndex / (8 * 8)
    //   );
    #define BRICK_INDEX_TO_COORDS(brickIndex) \
        uvec3((brickIndex & 7), ((brickIndex >> 3) & 7), (brickIndex >> 6))
#else
    #error BRICK_SIDE_LENGTH macro must have value 8 for now
#endif

#if BRANCHING_FACTOR == 2
    #define NODES_PER_TILE 8
    #define NODE_TO_TILE(nodeIndex) (nodeIndex >> 3)
#elif BRANCHING_FACTOR == 4
    #define NODES_PER_TILE 64
    #define NODE_TO_TILE(nodeIndex) (nodeIndex >> 6)
#else
    #error BRANCHING_FACTOR macro mus wave value 2 or 4
#endif

#define SUBDIVIDE_THIS_BIT 0x80000000
#define HAS_BRICK_BIT      0x40000000
#define NODE_FLAGS_MASK    0xC0000000
#define CHILD_POINTER_MASK 0x3FFFFFFF

#define SOLID_NODE 1
#define EMPTY_NODE 0

// SDF settings
#define MAX_DISTANCE     1000000.0

#define PRIMITIVE_SPHERE 0

#define SQRT_3 1.73205080757


// Shader data
// ------------

layout(local_size_x = BRICK_SIDE_LENGTH, local_size_y = BRICK_SIDE_LENGTH, local_size_z = BRICK_SIDE_LENGTH) in;

// node pool
layout(binding = 0, offset = 0) uniform atomic_uint nodeCount;
layout(std430, binding = 1) buffer NodePool { uint nodes[]; };
layout(std430, binding = 2) buffer NodeDataPool { uint nodeData[]; };
layout(std430, binding = 3) buffer VertexBuffer { vec4 nodeVertices[]; };

uniform uint levelBeginIndex;
uniform uint allowSubdivision;

// brick pool
layout(binding = 0, offset = 4) uniform atomic_uint brickCount;
layout(r32f, binding = 1) writeonly restrict uniform image3D brickPoolTexture;
uniform uint BricksInOneDimension;

// Primitive Cloud
struct Edit {
    uint type;
    uint op;
    uint blending;
    uint padding1;
    vec3 position;
    float padding2;
    vec4 data;
};
layout(std430, binding = 4) buffer Input { Edit edits[]; };
uniform uint editCount;
uniform vec4 correctionVector;

shared uint divide; // place in group-shared memory into which voting whenever node will be subdivided will take place.
shared uint brickIndex;


// Shader implementation
// ---------------------

uint newNode(uint tileIndex, uint flags) {
    return (tileIndex & CHILD_POINTER_MASK) | (flags & NODE_FLAGS_MASK);
}

float distanceToEdit(Edit edit, vec3 position) {
    switch (edit.type) {
        case PRIMITIVE_SPHERE: return distance(edit.position - correctionVector.xyz, position) - edit.data.x;
        default:               return MAX_DISTANCE;
    }
}


void writeToVolumeTexture(ivec3 brickVoxelCoord, float sdfValue) {
    // each voxel writes its own value
    imageStore(brickPoolTexture, brickVoxelCoord, vec4(sdfValue, 0, 0, 0));
    
    // handle the border region
    ivec3 cornerShift   = ivec3(0, 0, 0);
    uint  corderCounter = 0;
    
    #define STORE_VALUE_WITH_SIFT(shift) imageStore(brickPoolTexture, brickVoxelCoord + shift, vec4(sdfValue, 0, 0, 0))
    #define PROCESS_EDGE(sx, sy, sz) \
        STORE_VALUE_WITH_SIFT(ivec3(sx, sy, sz)); \
        cornerShift += ivec3(sx, sy, sz); \
        corderCounter++
    
    // this branching probably can be speeded up by some clever register array and one or two branches
    
    if (gl_LocalInvocationID.x == 0) {
        PROCESS_EDGE(-1, 0, 0);
    } else if (gl_LocalInvocationID.x == 7) {
        PROCESS_EDGE(1, 0, 0);
    }
    
    if (gl_LocalInvocationID.y == 0) {
        PROCESS_EDGE(0, -1, 0);
    } else if (gl_LocalInvocationID.y == 7) {
        PROCESS_EDGE(0, 1, 0);
    }
    
    if (gl_LocalInvocationID.z == 0) {
        PROCESS_EDGE(0, 0, -1);
    } else if (gl_LocalInvocationID.z == 7) {
        PROCESS_EDGE(0, 0, 1);
    }
    
    // if (corderCounter == 3) {
    //     STORE_VALUE_WITH_SIFT(cornerShift);
    // }

    // memoryBarrierImage(); // this will probably wont be needed, memory is not read in this shader
}

void main() {
    if (gl_LocalInvocationIndex == 0) {
        divide = 0; // prepare local memory
    }
    barrier();
    
    uint nodeIndex = levelBeginIndex + gl_WorkGroupID.x;
    vec4 nodeVertex  = nodeVertices[nodeIndex];
   
    ivec3 branchCoefficients = ivec3(gl_LocalInvocationID) - (BRICK_SIDE_LENGTH / 2);
    float fullStep           = 1.0 / float(BRICK_SIDE_LENGTH); // hopefully the only FP division and possibly optimize into multiplication by 0.5, 0.25 etc.
    float halfStep           = fullStep * 0.5;
    vec3  shiftVector        = fullStep * vec3(branchCoefficients) + halfStep;
    vec3  voxelCenter        = nodeVertex.w * shiftVector + nodeVertex.xyz;
    
    // compute distance to the voxel center -> sdfValue
    float sdfValue = MAX_DISTANCE;
    for (int i = 0; i < editCount; ++i) {
        Edit edit = edits[i];
        float distanceToPrimitive = distanceToEdit(edit, voxelCenter);
        if (abs(distanceToPrimitive) < abs(sdfValue)) {
            sdfValue = distanceToPrimitive;
        }
    }
    
    // vote if voxel intersects sdf surface
    float voxelSize = SQRT_3 * (fullStep * nodeVertex.w) * 0.5;
    if (abs(sdfValue) < voxelSize) {
        atomicAdd(divide, 1);
    }
    barrier();
    
    // If division was voted all threads will enter this branch
    //   - In this branch will be saved evaluated volume as new brick
    if (divide != 0) {
        
        // first thread will reserve new brick
        if (gl_LocalInvocationIndex == 0) {
            brickIndex = atomicCounterIncrement(brickCount);
        }
        barrier();
        
        // all threads will find voxel coordinate in brick pool based on the brick index
        uvec3 brickCoords = BRICK_INDEX_TO_COORDS(brickIndex);
        uvec3 voxelCoord  = 10 * brickCoords + uvec3(1, 1, 1) + gl_LocalInvocationID;
        // uvec3 voxelCoord  = 8 * brickCoords + gl_LocalInvocationID;
        
        writeToVolumeTexture(ivec3(voxelCoord), sdfValue);
        
        // I am fist thread in the group and will divide this node
        if (gl_LocalInvocationIndex == 0 ) {
            uint flags = HAS_BRICK_BIT;
            uint newTileFirstNodeIndex = 0;
            nodeData[nodeIndex] = brickIndex; // TODO: store 3d coordinates in 10b each ?
            
            if (allowSubdivision != 0) {
                flags |= SUBDIVIDE_THIS_BIT;
                newTileFirstNodeIndex = atomicCounterAdd(nodeCount, NODES_PER_TILE);
            }
            
            nodes[nodeIndex] = newNode(NODE_TO_TILE(newTileFirstNodeIndex), flags); // link this node to its newly created child and keep its flags
        }
    } else {
        if (gl_LocalInvocationIndex == 0 ) {
            nodes[nodeIndex] = newNode(0, 0); // make sure that brick and subdivide bits are zero
            nodeData[nodeIndex] = (sdfValue < 0) ? SOLID_NODE : EMPTY_NODE;
        }
    }
}
